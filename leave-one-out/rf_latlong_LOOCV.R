rf_latlong <- function(training, testing, variables, coast=NULL, train_path, nthread=8){
  set.seed(1234)
  folds <- createFolds(training[,'Populations'], k = 5, returnTrain = T)
  load('sample_feature/coastlines.rdata')  
  coast <- coastlines
  
  trControl <-  trainControl( # regression
    method = "cv",
    number = 5,
    verboseIter = FALSE,
    returnData = FALSE,
    search = "grid",
    savePredictions = "final",
    allowParallel = T,
    index = folds)
  
  tune_grid <- expand.grid(.mtry = c(1:15)) 
  
  training$rowIndex <- as.numeric(rownames(training))
  Xgb_latitude <- train(x = training[,variables],
                        y = training[,'latitude'],
                        method = "rf",
                        trControl = trControl,
                        tuneGrid = tune_grid ,
                        nthread = nthread
  )
  
  Xgb_longitude <- train(x = training[,variables],
                         y = training[,'longitude'],
                         method = "rf",
                         trControl = trControl,
                         tuneGrid = tune_grid ,
                         nthread = nthread
  )
  
  
  latPred <- predict(Xgb_latitude, newdata = testing[,variables])
  longPred <- predict(Xgb_longitude, newdata = testing[,variables])
  
  #adjust out of bounds predictions
  message('adjust out of bounds predictions')
  longPred[longPred > 180] <- 180
  longPred[longPred < -180] <- -180
  latPred[latPred > 90] <- 90
  latPred[latPred < -90] <- -90
  #Pull to nearest coastline if provided
  message('Pull to nearest coastline if provided')
  find_coast <- function(long, lat) { # find the closet point on the coast for the given long and lat
    distances_from_coastline <-
      sp::spDistsN1(coast, c(long, lat), longlat = TRUE)

    closest_point <-  which.min(distances_from_coastline)
    new_coords <- coast[closest_point,]

    return(new_coords)

  }

  if (!is.null(coast)) {
    message('toAdjust generated by function map.where')
    # find the longPred / latPred that are not on world latitude/longitude
    toAdjust <-
      which(is.na(maps::map.where(database = "world", longPred, latPred)))

    if(length(toAdjust) > 0){
      # apply find_coast function to adjust the latitude and longitude of given toAdjust index
      message('adjusted generated by mapply find_coast and longPred, latPred')
      adjusted <- mapply(find_coast, long = longPred[toAdjust], lat = latPred[toAdjust])

      # update the adjusted lat and long
      longPred[toAdjust] <- adjusted[1,]
      latPred[toAdjust] <- adjusted[2,]
    }
  }
  
  mean_r2 <- mean(c(Xgb_longitude$results$Rsquared[which(Xgb_longitude$results$mtry == Xgb_longitude$bestTune[[1]])],
                  Xgb_latitude$results$Rsquared[which(Xgb_latitude$results$mtry == Xgb_latitude$bestTune[[1]])]
                  ))
  
  message('return')
  return(list(list(latPred, longPred), 
              mean_r2) )
  
  
}





